using IGDB;
using IGDB.Serialization;
using Microsoft.Extensions.Http;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Polly;
using RestEase;
using RestEase.Implementation;

namespace gremlin_eye.Server.Services
{
    //The Base IGDBClient always directly hits the IGDB endpoint, making it impossible to use it with the proxy
    //In a local environment, we can just call igdb directly, but it's good form to use a proxy for a deployed app.
    //Therefore, a custom ProxyClient class was made to be used as the default when the proxyUrl is set, and otherwise falls back to the base IgdbClient

    //Since the TokenManager is an internal class in the IGDB Api, we make a clone to use here to make use of the oauth tokens
    internal class IGDBTokenManager
    {
        private readonly TwitchOAuthClient _twitchClient;
        private readonly ITokenStore _tokenStore;

        public IGDBTokenManager(ITokenStore tokenStore, TwitchOAuthClient twitchClient)
        {
            _tokenStore = tokenStore;
            _twitchClient = twitchClient;
        }

        public async Task<TwitchAccessToken> AcquireTokenAsync()
        {
            var currentToken = await _tokenStore.GetTokenAsync();
            if (currentToken?.HasTokenExpired() == false)
            {
                return currentToken;
            }

            return await RefreshTokenAsync();
        }

        public async Task<TwitchAccessToken> RefreshTokenAsync()
        {
            var accessToken = await _twitchClient.GetClientCredentialTokenAsync();
            accessToken.TokenAcquiredAt = DateTimeOffset.UtcNow;
            var storedToken = await _tokenStore.StoreTokenAsync(accessToken);

            return storedToken;
        }
    }
    
    public sealed class ProxyClient
    {
        private readonly IGDBTokenManager _tokenManager;
        private readonly HttpClient _httpClient;

        private readonly string _apiKey;

        public static JsonSerializerSettings DefaultJsonSerializerSettings = new JsonSerializerSettings()
        {
            Converters = new List<JsonConverter>() {
          new IdentityConverter(),
          new UnixTimestampConverter()
        },
            ContractResolver = new DefaultContractResolver()
            {
                NamingStrategy = new SnakeCaseNamingStrategy()
            }
        };

        public ProxyClient(string clientId, string clientSecret, string proxyUrl, string apiKey) :
            this(clientId, clientSecret, proxyUrl, apiKey, new InMemoryTokenStore(), null)
        {
        }

        public ProxyClient(string clientId, string clientSecret, string proxyUrl, string apiKey, ITokenStore tokenStore) :
            this(clientId, clientSecret, proxyUrl, apiKey, tokenStore, null)
        {
        }

        public ProxyClient(string clientId, string clientSecret, string proxyUrl, string apiKey, ITokenStore tokenStore, IAsyncPolicy<HttpResponseMessage> policy)
        {
            if(clientId == null)
            {
                throw new ArgumentNullException(nameof(clientId), "Missing IGDB client ID. You can find this in the IGDB developer portal.");
            }
            if (clientSecret == null)
            {
                throw new ArgumentNullException(nameof(clientSecret), "Missing IGDB client secret. You can find this in the IGDB developer portal.");
            }
            if (proxyUrl == null)
            {
                throw new ArgumentNullException(nameof(proxyUrl), "Missing the URL for the API Gateway proxy. It is set up in the CloudFormation stack.");
            }
            if (apiKey == null)
            {
                throw new ArgumentNullException(nameof(apiKey), "Missing the API Key generated by the CloudFormation stack. Retrieve it and try again.");
            }
            if (tokenStore == null)
            {
                throw new ArgumentNullException(nameof(tokenStore),
                  "A ITokenStore is required. Pass InMemoryTokenStore if you do not have a custom store implemented.");
            }

            RequestModifier requestModifier = async (request, cancellationToken) =>
            {
                var twitchToken = await _tokenManager.AcquireTokenAsync();

                if (twitchToken?.AccessToken != null)
                {
                    request.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(
                      "Bearer", twitchToken.AccessToken);
                }
            };

            _apiKey = apiKey;
            _tokenManager = new IGDBTokenManager(tokenStore, new TwitchOAuthClient(clientId, clientSecret));
            _httpClient = new HttpClient(new PolicyHttpMessageHandler(policy)
            {
                InnerHandler = new ModifyingClientHttpHandler(requestModifier)
            });
            _httpClient.BaseAddress = new Uri(string.Format("{0}/v4", proxyUrl));
        }

        public async Task<T[]> QueryAsync<T>(string endpoint, string query = null)
        {
            try
            {
                return await QueryIgdbAsync<T>(endpoint, query);
            }
            catch (ApiException apiEx)
            {
                // Acquire new token and retry request (once)
                if (IGDBClient.IsInvalidTokenResponse(apiEx))
                {
                    await _tokenManager.RefreshTokenAsync();

                    return await QueryIgdbAsync<T>(endpoint, query);
                }

                // Pass up any other exceptions
                throw apiEx;
            }
        }

        private async Task<T[]> QueryIgdbAsync<T>(string endpoint, string query)
        {
            var request = new HttpRequestMessage()
            {
                RequestUri = new Uri(endpoint),
                Method = HttpMethod.Post,
                Content = new StringContent(query)
            };
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("x-api-key", _apiKey);

            var response = await _httpClient.SendAsync(request);
            var resultString = await response.Content.ReadAsStringAsync();
            var resultObject = JsonConvert.DeserializeObject<T[]>(resultString, DefaultJsonSerializerSettings);
            if (resultObject == null)
            {
                throw new InvalidOperationException("Deserialization returned null for type " + typeof(T).FullName);
            }
            return resultObject;
        }
    }
}
